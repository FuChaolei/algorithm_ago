{"version":3,"file":"algm.cjs.production.min.js","sources":["../src/treeNode.ts","../src/listNode.ts","../src/array.ts","../src/graph.ts","../src/hopcroftKarp.ts","../src/interval.ts","../src/math.ts","../src/rbst.ts","../src/pq.ts","../src/skiplist.ts","../src/segment.ts","../src/unionFind.ts","../src/tree.ts"],"sourcesContent":["export class TreeNode<T = number> {\n  constructor(\n    public val: T,\n    public left: TreeNode<T> | null = null,\n    public right: TreeNode<T> | null = null\n  ) {}\n}\n\n/**\n * Encodes a tree to a single string.\n *\n * @mermaid\n * graph LR\n *   1 --- 2\n *   1 --- 3\n *   3 --- 4\n *   3 --- 5\n * @example\n * ```js\n * serialize(root) // => '[1,2,3,null,null,4,5]'\n * ```\n */\nfunction serialize<T = number>(root: TreeNode<T> | null): string {\n  if (!root) {\n    return JSON.stringify([])\n  }\n  let arr: (T | null)[] = []\n  let queue: (TreeNode<T> | null)[] = [root]\n  while (queue.length) {\n    let node = queue.shift()\n    if (node) {\n      arr.push(node.val)\n      queue.push(node.left)\n      queue.push(node.right)\n    } else {\n      arr.push(null)\n    }\n  }\n  let i = arr.length - 1\n  while (arr[i] === null) {\n    i--\n  }\n  arr.length = i + 1\n  return JSON.stringify(arr)\n}\n\nfunction serializeArr<T = number>(arr: (TreeNode<T> | null)[]): string {\n  const outArr = []\n  for (let i = 0; i < arr.length; i++) {\n    outArr.push(serialize(arr[i]))\n  }\n  return '[' + outArr.join(',') + ']'\n}\n\n/**\n * Decodes your encoded data to tree.\n */\nfunction deserialize<T = number>(originData: string): TreeNode<T> | null {\n  const data = JSON.parse(originData)\n  if (!data.length) {\n    return null\n  }\n  let val = data.shift() as T\n  let root = new TreeNode(val)\n  let queue: TreeNode<T>[] = [root]\n  while (queue.length) {\n    let node = queue.shift() as TreeNode<T>\n    let leftVal = data.shift()\n    if (leftVal === undefined) {\n      return root\n    }\n    if (leftVal !== null) {\n      let left = new TreeNode(leftVal)\n      node.left = left\n      queue.push(left)\n    }\n    let rightVal = data.shift()\n    if (rightVal === undefined) {\n      return root\n    }\n    if (rightVal !== null) {\n      let right = new TreeNode(rightVal)\n      node.right = right\n      queue.push(right)\n    }\n  }\n  return root\n}\n\nfunction deserializeArr<T = number>(\n  originData: string\n): (TreeNode<T> | null)[] {\n  const data: (T | null)[][] = JSON.parse(originData)\n  if (!data.length) {\n    return []\n  }\n  let outArr: (TreeNode<T> | null)[] = []\n  for (let i = 0; i < data.length; i++) {\n    outArr.push(deserialize(JSON.stringify(data[i])))\n  }\n  return outArr\n}\n\nexport { serialize, deserialize, serializeArr, deserializeArr }\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n","export class ListNode<T = number> {\n  constructor(\n    public val: T | undefined = undefined,\n    public next: ListNode<T> | null = null\n  ) {}\n}\n/**\n * Encodes a list to a single string.\n *\n * @mermaid\n * graph LR\n *   1 --- 2\n *   2 --- 3\n *   3 --- 4\n *   4 --- 5\n * @example\n * ```js\n * serialize(root) // => '[1,2,3,4,5]'\n * ```\n */\nexport function serialize<T = number>(head: ListNode<T> | null): string {\n  if (!head) {\n    return JSON.stringify([])\n  }\n  let arr = []\n  let node: ListNode<T> | null = head\n  while (node) {\n    arr.push(node.val)\n    node = node.next\n  }\n  return JSON.stringify(arr)\n}\n\nexport function serializeArr<T = number>(arr: (ListNode<T> | null)[]): string {\n  let out = []\n  for (let i = 0; i < arr.length; i++) {\n    out.push(serialize(arr[i]))\n  }\n  return '[' + out.join(',') + ']'\n}\n\n/**\n * Decodes your encoded data to list.\n */\nexport function deserialize<T = number>(\n  originData: string\n): ListNode<T> | null {\n  const data = JSON.parse(originData)\n  let header = new ListNode<T>()\n  let node = header\n  for (let i = 0; i < data.length; i++) {\n    node.next = new ListNode(data[i])\n    node = node.next\n  }\n  return header.next\n}\n\nexport function deserializeArr<T = number>(\n  originData: string\n): (ListNode<T> | null)[] {\n  const arr: T[][] = JSON.parse(originData)\n  let out: (ListNode<T> | null)[] = []\n  for (let i = 0; i < arr.length; i++) {\n    out.push(deserialize(JSON.stringify(arr[i])))\n  }\n  return out\n}\n/**\n * reverse a list\n */\nexport function reverseList<T>(head: ListNode<T> | null): ListNode<T> | null {\n  if (!head) {\n    return null\n  }\n  let prev = null\n  let cur: ListNode<T> | null = head\n  while (cur) {\n    let next: ListNode<T> | null = cur.next\n    cur.next = prev\n    prev = cur\n    cur = next\n  }\n  return prev\n}\n","/**\n * Initializes an array with initial value of 0\n * @return return the new array\n * @category array\n * @example\n * ```js\n * initArray(3) // => [0,0,0]\n * initArray([3,2]) // => [[0,0],[0,0],[0,0]]\n * ```\n */\nexport function initArray(dimension: number | number[]): any[] {\n  if (Number.isInteger(dimension)) {\n    return Array(dimension).fill(0)\n  }\n  if (!Array.isArray(dimension)) {\n    throw new Error('dimension sould be int or int array')\n  }\n  if (dimension.length === 1) {\n    let len = dimension[0]\n    return Array(len).fill(0)\n  }\n\n  let len = dimension[0]\n  return Array.from(Array(len), () => [...initArray(dimension.slice(1))])\n}\n/**\n * Initializes a two-dimensional array\n * @param m\n * @param n\n * @param value the default value of element\n * @category array\n * @return return the new array\n * @example\n * ```js\n * init2Array(2,3) // => [[0,0,0],[0,0,0]]\n * ```\n */\nexport function init2Array(m: number, n: number, value = 0): number[][] {\n  const arr: number[][] = []\n  for (let i = 0; i < m; i++) {\n    arr[i] = Array(n).fill(value)\n  }\n  return arr\n}\n\n/**\n * merge all overlapped intervals\n * @param intervals\n * @category array\n * @example\n * ```js\n * mergeArray([[0,1],[1,2],[3,4]]) // => [[0,2],[3,4]]\n * ```\n */\nexport function mergeArray(intervals: number[][]) {\n  if (!intervals.length) {\n    return []\n  }\n  intervals.sort((arr1, arr2) => arr1[0] - arr2[0])\n  let prev = intervals[0]\n  let result = []\n  for (let i = 1; i < intervals.length; i++) {\n    if (intervals[i][0] <= prev[1]) {\n      prev = [prev[0], Math.max(intervals[i][1], prev[1])]\n    } else {\n      result.push(prev)\n      prev = intervals[i]\n    }\n  }\n  result.push(prev)\n  return result\n}\n\n/**\n * Intersection of two array\n * @param {any[]} arr1\n * @param {any[]} arr2\n * @return {any[]}\n * @category array\n * @example\n * ```js\n * intersect([1,2],[2,3]) // => [2]\n * ```\n */\nexport function intersect<T>(arr1: T[], arr2: T[]): T[] {\n  const set = new Set(arr1)\n  let result = []\n\n  for (let i = 0; i < arr2.length; i++) {\n    const e = arr2[i]\n    if (set.has(e)) {\n      result.push(e)\n    }\n  }\n  return result\n}\n\n/**\n *  the min sum to make array unique by subtracting of the element\n * @param arr an array of int\n * @category array\n * @example\n * ```js\n * countOfUniqueD([3,3,1]) // => 1,the unique array should be [3,2,1], 3->2\n * countOfUniqueD([3,3,3]) // => 3,the unique array should be [3,2,1], 3->2, 3->1\n * ```\n */\nexport function countOfUniqueD(arr: number[]): number {\n  let result = 0\n  if (arr.length <= 1) {\n    return 0\n  }\n  sortD(arr)\n  let t = arr[0]\n  for (let i = 1; i < arr.length; i++) {\n    t--\n    if (t > arr[i]) {\n      t = arr[i]\n    } else {\n      result += arr[i] - t\n    }\n  }\n  return result\n}\n\n/**\n * the min sum to make array unique by increasing the element\n * @param arr an array of int\n * @category array\n * @example\n * ```js\n * countOfUniqueA([1,1,2]) // => 2,the unique array should be [1,2,3]\n * countOfUniqueA([0,2,2,2,3]) // => 5 ,the unique array should be [0,2,3,4,5], 2->4,2->5\n * ```\n */\nexport function countOfUniqueA(arr: number[]) {\n  let result = 0\n  if (arr.length <= 1) {\n    return 0\n  }\n  sortA(arr)\n  let t = arr[0]\n  for (let i = 1; i < arr.length; i++) {\n    t++\n    if (t < arr[i]) {\n      t = arr[i]\n    } else {\n      result += t - arr[i]\n    }\n  }\n  return result\n}\n\n/**\n * reverse the array from start to end\n * @category array\n * @example\n * ```js\n * reverse([2,3,4]) // => [4,3,2]\n * ```\n */\nexport function reverse<T>(arr: T[], start = 0, end = arr.length - 1): T[] {\n  for (let i = start; i < (start + end) / 2; i++) {\n    let t = arr[i]\n    arr[i] = arr[start + end - i]\n    arr[start + end - i] = t\n  }\n  return arr\n}\ninterface IndexObj<T> {\n  index: number\n  value: T\n}\n/**\n * return an index arr\n * @category array\n * @example\n * ```js\n * toIndexArr([1,2,3]) // => [{index:0,value:1},{index:1,value:2},{index:2,value:3}]\n * ```\n */\nexport function toIndexArr<T>(arr: T[]): IndexObj<T>[] {\n  let indexArr: IndexObj<T>[] = []\n  for (let i = 0; i < arr.length; i++) {\n    indexArr[i] = {\n      index: i,\n      value: arr[i],\n    }\n  }\n  return indexArr\n}\n\nfunction compare(v1: number | string, v2: number | string) {\n  if (typeof v1 !== typeof v2) {\n    throw new Error('the type of key should be the same')\n  }\n  if (typeof v1 !== 'string') {\n    return v1 - (v2 as number)\n  } else {\n    return v1.localeCompare(v2 as string)\n  }\n}\ntype GetCompareKey<T> = (a: T) => any\n/**\n * Sort the array in ascending order by key\n * @param  arr the array\n * @param  fn return the key to sort, default key is value\n * @param  fn2 if the key is equal, using the second key\n * @category array\n * @example\n * ```js\n * sortA([3,1,2]) // => [1,2,3]\n * sortA([{height:3},{height:2},{height:1}],x=>x.height) // => [{height:1},{height:2},{height:3}]\n * sortA(['ca','ba','bd']) // => ['ba','bd','ca']\n * ```\n */\nexport function sortA<T>(arr: T[], fn: GetCompareKey<T> = x => x, fn2 = fn) {\n  return arr.sort((x, y) => {\n    const key1 = fn(x)\n    const key2 = fn(y)\n    const r = compare(key1, key2)\n    if (r) {\n      return r\n    }\n    const key3 = fn2(x)\n    const key4 = fn2(y)\n    return compare(key3, key4)\n  })\n}\n/**\n * Sort the array in descending order by key\n * will change the origin array\n * @param  arr the array\n * @param  getCompareKey return the key to sort\n * @param  getCompareKey2 if the key is equal, using the second key\n * @category array\n * @example\n * ```js\n * sortD([3,1,2]) // => [3,2,1]\n * sortD([{height:3},{height:2},{height:1}],x=>x.height) // => [{height:3},{height:2},{height:1}]\n * sortD(['ca','ba','bd']) // => ['ca','bd','ba']\n * sortD([{value:1,index:1},{value:2,index:3},{value:2,index:2}],x=>x.value,x=>x.index)\n * // => [{value:2,index:3},{value:2,index:2},{value:1,index:1}]\n * ```\n */\nexport function sortD<T>(\n  arr: T[],\n  getCompareKey: GetCompareKey<T> = x => x,\n  getCompareKey2 = getCompareKey\n) {\n  return arr.sort((x, y) => {\n    const key1 = getCompareKey(x)\n    const key2 = getCompareKey(y)\n    const r = compare(key2, key1)\n    if (r) {\n      return r\n    }\n    const key3 = getCompareKey2(x)\n    const key4 = getCompareKey2(y)\n    return compare(key4, key3)\n  })\n}\n\n/**\n * Return the last value\n * @param arr the array\n * @category array\n * ```js\n * last([2,1,5]) // => 5\n * last([]) // => undefined\n * ```\n */\nexport function last<T>(arr: T[]): T {\n  return arr[arr.length - 1]\n}\ninterface PlainObj {\n  [key: string]: any\n}\n\n/**\n * Push a value to a property of the object\n * @example\n * ```js\n * const obj={}\n * push(obj,'key1','a')\n * push(obj,'key1','b')\n * push(obj,'key2','c')\n * console.log(obj) // => {key1:['a','b'],key2:['c']}\n * ```\n */\nexport function push(obj: PlainObj, key: string | number, item: any) {\n  if (!obj[key]) {\n    obj[key] = []\n  }\n  obj[key].push(item)\n}\n/**\n * Gets a unique key based on the parameter\n * ```js\n * key('abc','bd') // => 'abc#bd'\n * key(['a','b']) // => 'a#b'\n * ```\n */\nexport function key(\n  ...args: (number | string)[] | (number | string)[][]\n): string {\n  if (Array.isArray(args[0])) {\n    return args[0].join('#')\n  }\n  return args.join('#')\n}\n\n/**\n * compute the sum of an array\n * @category array\n * @example\n * ```js\n * sum([1,2,3]) // => 6\n * sum([]) // => 0\n * ```\n */\nexport function sum(arr: number[]) {\n  return arr.reduce((prev, cur) => prev + cur, 0)\n}\n\n/**\n * Get the max value\n * @category array\n * @example\n * ```js\n * max(1,3,2) // => 3\n * max([1,3,2]) // => 3\n * ```\n */\nexport function max(...arg: number[] | number[][]): number {\n  if (!Array.isArray(arg[0])) {\n    return Math.max(...(arg as number[]))\n  }\n\n  arg = arg[0]\n\n  if (arg.length <= 10000) {\n    return Math.max(...arg)\n  }\n\n  let max = -Infinity\n\n  for (const num of arg) {\n    max = Math.max(max, num)\n  }\n\n  return max\n}\n\n/**\n * Get the min value\n * @category array\n * @example\n * ```js\n * min(1,3,2) // => 1\n * min([1,3,2]) // => 1\n * ```\n */\nexport function min(...arg: number[] | number[][]): number {\n  if (!Array.isArray(arg[0])) {\n    return Math.min(...(arg as number[]))\n  }\n\n  arg = arg[0]\n\n  if (arg.length <= 10000) {\n    return Math.min(...arg)\n  }\n\n  let min = -Infinity\n\n  for (const num of arg) {\n    min = Math.min(min, num)\n  }\n\n  return min\n}\n\n/**\n * return a new arr that does not contains duplicate elements.\n * @category array\n * @example\n * ```js\n * unique([1,1,2,2,2,6,1]) //=> [1,2,6]\n * ```\n */\nexport function unique<T>(arr: T[]): T[] {\n  return [...new Set(arr)]\n}\n","/**\n * Calculate the connectivity degree according to the undirected graph adjacency array.\n * @param {number[][]} adjArr adjacency array\n * @param {number} n vertex number\n * @category Graph\n * @mermaid\n * graph LR\n *   0 --- 4\n *   1 --- 2\n *   2 --- 3\n * @example\n * ```js\n * getConnectedNumByAdjArr([[4],[2],[1,3],[2],[0]]) // => 2\n * ```\n */\nexport function getConnectedNumByAdjArr(\n  adjArr: number[][],\n  n: number = adjArr.length\n) {\n  let set: Set<number> = new Set()\n  let num = 0\n  for (let i = 0; i < n; i++) {\n    if (!set.has(i)) {\n      num++\n      dfs(i, set, adjArr)\n    }\n  }\n  return num\n}\nfunction dfs(node: number, set: Set<number>, adjArr: number[][]) {\n  set.add(node)\n  const adjNodes: number[] = adjArr[node] || []\n  for (let i = 0; i < adjNodes.length; i++) {\n    if (!set.has(adjNodes[i])) {\n      dfs(adjNodes[i], set, adjArr)\n    }\n  }\n}\n\n/**\n * Calculate the connectivity degree according to the undirected graph adjacency matrix.\n * @category Graph\n * @param {number[][]} adjMatrix 邻接矩阵\n */\nexport function getConnectedNumByAdjMatrix(adjMatrix: number[][]) {\n  let num = 0\n  const n = adjMatrix.length\n  let set: Set<number> = new Set()\n  for (let i = 0; i < n; i++) {\n    if (!set.has(i)) {\n      num++\n      dfs2(i, set, adjMatrix)\n    }\n  }\n  return num\n}\n\nfunction dfs2(index: number, set: Set<number>, isConnected: number[][]) {\n  set.add(index)\n  for (let j = 0; j < isConnected.length; j++) {\n    if (isConnected[index][j] && !set.has(j)) {\n      dfs(j, set, isConnected)\n    }\n  }\n}\n","/**\n * check if the value is `undefined`\n */\nfunction isNil(value: any): value is undefined {\n  return value === undefined\n}\ninterface DistMap {\n  [key: string]: number\n}\n/**\n * bipartite matching algorithms\n *\n * the [Hopcroft–Karp algorithm](https://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm) is an algorithm that takes as input a bipartite graph and produces as output a maximum cardinality matching\n *\n * bipartite graph contains two vertex set X and Y\n * @param m the number of X\n * @param adj the adjacency array of X\n * @category Graph\n * @example\n * ```js\n * hopcroftKarp(5,[[5, 6], [5, 9], [7, 8], [5, 9], [6, 8]])\n * // => Map(10){ 0=>6,1=>9,2=>7,3=>5,4=>8,6=>0,7=>2,8=>4,9=>1 }\n * ```\n */\nexport function hopcroftKarp(m: number, adjArr: number[][]) {\n  // record the matching vertices\n  let map = new Map<number, number>()\n  let dist: DistMap = {}\n  while (bfs(map, dist, m, adjArr)) {\n    // dfs stage\n    for (let i = 0; i < m; i++) {\n      // the augmenting-path start from a unmatched vertice\n      if (!map.has(i)) {\n        dfs(i, map, dist, m, adjArr)\n      }\n    }\n  }\n  return map\n}\n/**\n * compute the shortest distance of all the vertices in X\n * @param map record the matching vertices\n * @param dist the distance map of the vertices in X\n * @param m the number of X\n * @param adjArr the adjacency array of X\n */\nfunction bfs(\n  map: Map<number, number>,\n  dist: DistMap,\n  m: number,\n  adjArr: number[][]\n) {\n  let queue: number[] = []\n  // record the shortest length of augmenting-path\n  // in fact the shortest length is shortDis*2-1\n  let shortDis = Infinity\n  // init the distance of vertices in every bfs stage\n  // the distance is 0 when the vertice do not match, or that is Infinity\n  for (let i = 0; i < m; i++) {\n    if (!map.has(i)) {\n      dist[i] = 0\n      queue.push(i)\n    } else {\n      dist[i] = Infinity\n    }\n  }\n\n  while (queue.length) {\n    const node = queue.shift()!\n    // this ensure all the augmenting-path length in the next dfs stage equal shortDis\n    if (dist[node] >= shortDis) {\n      break\n    }\n    const adjNodes = adjArr[node]\n    for (let i = 0; i < adjNodes.length; i++) {\n      const adjNode = adjNodes[i]\n      const nextNode = map.get(adjNode)\n      if (isNil(nextNode)) {\n        // find a augmenting-path\n        shortDis = dist[node] + 1\n      } else if (dist[nextNode] === Infinity) {\n        dist[nextNode] = dist[node] + 1\n        queue.push(nextNode)\n      }\n    }\n  }\n  return shortDis < Infinity\n}\nfunction dfs(\n  node: number,\n  map: Map<number, number>,\n  dist: DistMap,\n  m: number,\n  adjArr: number[][]\n): boolean {\n  const adjNodes = adjArr[node]\n  for (let i = 0; i < adjNodes.length; i++) {\n    const adjNode = adjNodes[i]\n    const nextNode = map.get(adjNode)\n    //find a augmenting-path\n    if (isNil(nextNode)) {\n      map.set(node, adjNode)\n      map.set(adjNode, node)\n      return true\n    } else if (dist[nextNode] === dist[node] + 1) {\n      if (dfs(nextNode, map, dist, m, adjArr)) {\n        map.set(node, adjNode)\n        map.set(adjNode, node)\n        return true\n      }\n    }\n  }\n  // mark this vertice has fail,so is will not visit in current dfs stage\n  dist[node] = Infinity\n  return false\n}\n","import { sortA } from './array'\n/**\n * minimum number of intervals to cover the target interval\n * @category interval\n */\nexport function minIntervalCover(intervals: number[][]) {\n  sortA(intervals, v => v[0])\n  if (!intervals.length) {\n    return 0\n  }\n  let c = 1\n  let [, right] = intervals[0]\n  for (let i = 1; i < intervals.length; i++) {\n    if (intervals[i][0] <= right) {\n      right = Math.max(right, intervals[i][1])\n    } else {\n      c++\n      right = intervals[i][1]\n    }\n  }\n  return c\n}\n\n/**\n *\n * @param {number[][]} intervals\n * @category interval\n */\nexport function maxIntervalDisjoint(intervals: number[][]) {\n  sortA(intervals, v => v[1])\n\n  if (!intervals.length) {\n    return 0\n  }\n  let c = 1\n  let [, right] = intervals[0]\n\n  for (let i = 1; i < intervals.length; i++) {\n    const interval = intervals[i]\n    if (interval[0] > right) {\n      c++\n      right = interval[1]\n    }\n  }\n  return c\n}\n/**\n * @category interval\n */\nexport const medium = (function() {\n  let lastValue: any = null\n  return function(left: number, right: number) {\n    let m = Math.floor((left + right) / 2)\n    if (m === lastValue) {\n      m = Math.ceil((left + right) / 2)\n    }\n    lastValue = m\n    return m\n  }\n})()\n","/**\n * Randomly returns integers in [min, max)\n * @category math\n * @example\n * ```js\n * random(1,2) // => 1\n * random(2,8) // => 4\n * ```\n */\nexport function random(min: number, max: number) {\n  min = Math.ceil(min)\n  max = Math.floor(max)\n  return Math.floor(min + Math.random() * (max - min))\n}\n/**\n * Next bigger permutation\n * @param arr\n * @category math\n * @example\n * ```js\n * nextPermutation([1,2,3,4]) // => [1,2,4,3]\n * nextPermutation([4,3,2,1]) // => [1,2,3,4]\n * ```\n */\nexport function nextPermutation(arr: number[]) {\n  let i = arr.length - 1\n  while (i >= 1 && arr[i] <= arr[i - 1]) {\n    i--\n  }\n  if (i === 0) {\n    return arr.reverse()\n  }\n  i--\n  let min = arr[i + 1]\n  let index: number = i + 1\n  for (let j = arr.length - 1; j > i; j--) {\n    if (arr[j] > arr[i] && arr[j] < min) {\n      min = Math.min(arr[j], min)\n      index = j\n    }\n  }\n  ;[arr[i], arr[index]] = [arr[index], arr[i]]\n  for (let j = i + 1; j <= Math.floor((i + arr.length) / 2); j++) {\n    ;[arr[j], arr[arr.length + i - j]] = [arr[arr.length + i - j], arr[j]]\n  }\n  return arr\n}\n\n/**\n * Get the greatest common divisor of a and b\n * @category math\n * @example\n * ```js\n * gcd(4,2) // => 2\n * gcd(9,6) // => 3\n * ```\n */\nexport function gcd(a: number, b: number): number {\n  if (b === 0) {\n    return a\n  }\n  return gcd(b, a % b)\n}\n/**\n * The coordinates of the point [x,y] are rotated 90° anticlockwise around [x0,y0]\n * @category math\n * @example\n * ```js\n * rotate90([1,1],[2,2]) // => [1,3]\n * ```\n */\nexport function rotate90(\n  [x, y]: [number, number],\n  [x0, y0]: [number, number]\n): [number, number] {\n  return [x0 + y0 - y, x - x0 + y0]\n}\n\n/**\n * The coordinate of the point [x,y] are rotated 90° clockwise around [x0,y0]\n * @category math\n */\nexport function rotateCw90(\n  [x, y]: [number, number],\n  [x0, y0]: [number, number]\n): [number, number] {\n  return [y - y0 + x0, x0 - x + y0]\n}\n\n/**\n * Compute the number of permutations c(n,m)=n*(n-1)*...(n-m+1)/(m!)\n * @category math\n * @example\n * ```js\n * c(5,2) // => 10n\n * c(4,2) // => 6n\n * c(5,0) // => 1n\n * ```\n */\nexport function c(n: number, m: number): bigint {\n  if (m === 0) {\n    return 1n\n  }\n  const bm = BigInt(m)\n  const bn = BigInt(n)\n  let s = 1n\n  let s2 = 1n\n  for (let i = 0n; i < bm; i++) {\n    s *= bn - i\n  }\n  for (let i = 1n; i <= bm; i++) {\n    s2 *= i\n  }\n  return s / s2\n}\n\n/**\n * First compute the number of permutations c(n,m)=n*(n-1)*...(n-m+1)/(m!)\n * Then take the remainder of modulo 10 * * 9 + 7\n * @category math\n * @example\n * ```js\n * cm(5,2) // => 10\n * cm(4,2) // => 6\n * cm(5,0) // => 1\n * ```\n */\nexport function cm(n: number, m: number) {\n  const d = BigInt(10 ** 9 + 7)\n  return Number(c(n, m) % d)\n}\n\n/**\n * Returns the i th bit of the absolute value of num\n * @example\n * ```js\n * bit(9,1) // => 0\n * bit(4,2) // => 1\n * bit(3,0) // => 1\n * ```\n */\nexport function bit(num: number, i: number) {\n  if (num < 0) num = num * -1\n\n  while (i > 0) {\n    num = Math.floor(num / 2)\n    i--\n  }\n  return num % 2\n}\n\n/**\n * Get the number of 1 in the binary number\n * @param n the number\n * @example\n * ```js\n * bitCount(0) // => 0\n * bitCount(3) // => 2\n * bitCount(4) // => 1\n * ```\n */\nexport function bitCount(n: number) {\n  let c = 0\n\n  while (n) {\n    if (n % 2 === 1) {\n      c++\n    }\n\n    n = Math.floor(n / 2)\n  }\n\n  return c\n}\n\n/**\n * Compute the remainder of m mod n.\n * The remainder is greater than or equal to 0.\n * @param m\n * @param n\n * @example\n * ```js\n * mod(2,3) // => 2\n * mod(-2,3) // => 1\n * mod(3,2) // => 1\n * mod(-2,2) // => 0\n * ```\n */\nexport function mod(m: number, n: number) {\n  const remainder = m % n\n  if (remainder < 0) {\n    return remainder + n\n  }\n  return remainder\n}\n","import { random } from './math'\nclass RBSTNode<T> {\n  size = 1\n  constructor(\n    public val: T,\n    public left: RBSTNode<T> | null = null,\n    public right: RBSTNode<T> | null = null\n  ) {}\n}\ntype GetCompareKey = (a: any) => number\n/**\n * @category randomized binary search tree.\n * @description\n * a randomized binary search tree.\n * `search`, `insert`, `remove`, `find the k-th max value` achieve O(Logn) expected performance.\n * @example\n * ```js\n * const rbst = new RBST()\n * const arr=[1,7,3]\n * arr.forEach(v=>{\n *  rbst.insert(v)\n * })\n * rbst.search(3) // => 3\n * rbst.findKMax(1) // => 7\n * rbst.remove(3)\n * rbst.findKMax(2) // => 1\n *\n * ```\n */\nexport class RBST<T> {\n  root: RBSTNode<T> | null = null\n  mapValueKey: GetCompareKey\n  constructor(fn: GetCompareKey = x => x) {\n    this.mapValueKey = fn\n  }\n  /**\n   * Insert the item as the root of the tree.\n   * @param item\n   * @param tree\n   */\n  private insertAsRoot(item: T, tree: RBSTNode<T> | null): RBSTNode<T> {\n    if (!tree) {\n      return new RBSTNode(item)\n    }\n    const size = tree.size + 1\n    const key = this.mapValueKey(item)\n    const [left, right] = this.split(key, tree)\n    const newNode = new RBSTNode(item, left, right)\n    newNode.size = size\n    return newNode\n  }\n  /**\n   * Divide the tree into two parts :leftTree and rightTree.\n   * The leftTree key is less than the specified key,\n   * and the rightTree key is greater than the specified key.\n   * @param key\n   * @param tree\n   */\n  private split(\n    key: number,\n    tree: RBSTNode<T> | null\n  ): [RBSTNode<T> | null, RBSTNode<T> | null] {\n    if (!tree) {\n      return [null, null]\n    }\n    if (this.mapValueKey(tree.val) > key) {\n      let [leftTree, rightTree] = this.split(key, tree.left)\n      tree.left = rightTree\n      tree.size -= leftTree ? leftTree.size : 0\n      return [leftTree, tree]\n    } else {\n      let [leftTree, rightTree] = this.split(key, tree.right)\n      tree.right = leftTree\n      tree.size -= rightTree ? rightTree.size : 0\n      return [tree, rightTree]\n    }\n  }\n  /**\n   * merge the leftTree and rightTree into one tree.\n   * @param leftTree\n   * @param rightTree\n   */\n  private join(\n    leftTree: RBSTNode<T> | null,\n    rightTree: RBSTNode<T> | null\n  ): RBSTNode<T> | null {\n    const m = leftTree ? leftTree.size : 0\n    const n = rightTree ? rightTree.size : 0\n    const total = m + n\n    if (!total) return null\n    const r = random(0, n + m)\n    if (r < m) {\n      leftTree!.right = this.join(leftTree!.right, rightTree)\n      leftTree!.size = total\n      return leftTree\n    } else {\n      rightTree!.left = this.join(leftTree, rightTree!.left)\n      rightTree!.size = total\n      return rightTree\n    }\n  }\n  private _insert(item: T, tree: RBSTNode<T> | null) {\n    if (!tree) {\n      return this.insertAsRoot(item, tree)\n    }\n    const n = tree.size\n    const r = random(0, n + 1)\n    if (r === n) {\n      return this.insertAsRoot(item, tree)\n    } else if (this.mapValueKey(item) < this.mapValueKey(tree.val)) {\n      tree.left = this._insert(item, tree.left)\n    } else {\n      tree.right = this._insert(item, tree.right)\n    }\n    tree.size++\n    return tree\n  }\n  insert(item: T) {\n    this.root = this._insert(item, this.root)\n  }\n\n  search(key: number) {\n    let tree: RBSTNode<T> | null = this.root\n    while (tree) {\n      const curKey = this.mapValueKey(tree.val)\n      if (key === curKey) {\n        return tree.val\n      } else if (key < curKey) {\n        tree = tree.left\n      } else {\n        tree = tree.right\n      }\n    }\n    return null\n  }\n  remove(key: number) {\n    if (this.search(key) === null) {\n      return\n    }\n    let tree: RBSTNode<T> | null = this.root\n    let father = null\n    let p\n    while (tree) {\n      const curKey = this.mapValueKey(tree.val)\n      if (key === curKey) {\n        if (!father) {\n          this.root = this.join(tree.left, tree.right)\n        } else {\n          const newTree = this.join(tree.left, tree.right)\n          father[p as 'left' | 'right'] = newTree\n        }\n        return\n      } else if (key < curKey) {\n        father = tree\n        p = 'left'\n        tree.size--\n        tree = tree.left\n      } else {\n        father = tree\n        p = 'right'\n        tree.size--\n        tree = tree.right\n      }\n    }\n    return null\n  }\n  /**\n   * find the k-th max item\n   * @param k\n   */\n  findKMax(k: number) {\n    const root = this.root\n    if (!root) return null\n    const size = root.size\n    k = size + 1 - k\n    if (k > size) {\n      return null\n    }\n    let tree: RBSTNode<T> | null = root\n    let prevNum = 0\n    while (tree) {\n      const leftSize = tree.left?.size || 0\n      const curRank = prevNum + leftSize + 1\n      if (k === curRank) {\n        return tree.val\n      } else if (k < curRank) {\n        tree = tree.left\n      } else {\n        prevNum = curRank\n        tree = tree.right\n      }\n    }\n    return null\n  }\n}\n","type GetCompareKey<T> = (a: T) => number\n\nclass PQ<T> {\n  keys: T[]\n  mapValueKey: GetCompareKey<T>\n  constructor(keys: T[] = [], fn: GetCompareKey<T> = (x: any) => x) {\n    this.keys = [...keys]\n    this.mapValueKey = fn\n\n    for (let i = Math.floor((this.keys.length - 2) / 2); i >= 0; i--) {\n      this.sink(i)\n    }\n  }\n\n  insert(key: T) {\n    this.keys.push(key)\n    this.swim(this.keys.length - 1)\n  }\n\n  protected exch(i: number, j: number) {\n    ;[this.keys[i], this.keys[j]] = [this.keys[j], this.keys[i]]\n  }\n\n  protected less(i: number, j: number) {\n    return this.mapValueKey(this.keys[i]) - this.mapValueKey(this.keys[j]) < 0\n  }\n\n  protected swim(index: number) {\n    let father = Math.floor((index - 1) / 2)\n\n    while (father >= 0 && this.less(father, index)) {\n      this.exch(index, father)\n      index = father\n      father = Math.floor((father - 1) / 2)\n    }\n  }\n\n  protected sink(index: number) {\n    let len = this.keys.length\n    let j = index * 2 + 1\n\n    while (j < len) {\n      if (j + 1 < len && this.less(j, j + 1)) {\n        j++\n      }\n\n      if (this.less(index, j)) {\n        this.exch(index, j)\n        index = j\n        j = j * 2 + 1\n      } else {\n        break\n      }\n    }\n  }\n\n  protected peek() {\n    return this.keys[0]\n  }\n\n  protected poll() {\n    let head = this.peek()\n    this.exch(0, this.keys.length - 1)\n    this.keys.length = this.keys.length - 1\n    this.sink(0)\n    return head\n  }\n\n  isEmpty() {\n    return !this.keys.length\n  }\n\n  size() {\n    return this.keys.length\n  }\n}\n\n/**\n * @category priority queue\n * @example\n * ```js\n * const input =  [4, 3, 1]\n * const maxP = new MaxPQ(input)\n * maxP.max() //=> 4\n * maxP.insert(5)\n * maxP.max() //=> 5\n * maxP.insert(8)\n * maxP.max() //=> 8\n * maxP.delMax()\n * maxP.max() //=> 5\n * ```\n * Provide the specified key\n * ```js\n * const input = [{ name: 'xiao', age: 21 }, { name: 'wang', age: 22 }, { name: 'li', age: 25 }]\n * const maxP = new MaxPQ(input, v => v.age)\n * const m = maxP.max() //=> { name: 'li', age: 25 }\n * ```\n *\n */\nexport class MaxPQ<T> extends PQ<T> {\n  max() {\n    return this.peek()\n  }\n\n  delMax() {\n    return this.poll()\n  }\n}\n\n/**\n * @category priority queue\n * @example\n * ```js\n * const minPQ = new MinPQ([5, 1, 4, 2])\n * minPQ.min() // => 1\n * minPQ.delMin()\n * minPQ.min() // => 2\n * ```\n * Provide the specified key\n * ```js\n * const input = [{ name: 'xiao', age: 21 }, { name: 'wang', age: 22 }, { name: 'li', age: 25 }]\n * const minP = new MinPQ(input, v => v.age)\n * minP.min() // => { name: 'xiao', age: 21 }\n * ```\n */\nexport class MinPQ<T> extends PQ<T> {\n  constructor(keys: T[] = [], fn: GetCompareKey<T> = (x: any) => x) {\n    super(keys, x => -1 * fn(x))\n  }\n\n  min() {\n    return this.peek()\n  }\n\n  delMin() {\n    return this.poll()\n  }\n}\n","/**\n *   SkipList structure\n *   ---------------\n *  |     head(nil) |\n *  |       |       |\n *  |DoubleListNode | -> head(nil) - QuadListNode - QuadListNode - tail(nil)\n *  |       |       |      |                        |\n *  |DoubleListNode | -> head(nil) - QuadListNode - QuadListNode - tail(nil)\n *  |       |       |\n *  |     tail(nil) |\n *   ---------------\n *          ^\n *          |\n *          |\n *      DoubleList\n *\n *\n */\nexport class DoubleLinkNode<T> {\n  next: DoubleLinkNode<T>\n  prev: DoubleLinkNode<T>\n  val: QuadList<T>\n  constructor(val: QuadList<T>) {\n    this.next = this\n    this.prev = this\n    this.val = val\n  }\n}\nexport class DoubleLink<T> {\n  nil: DoubleLinkNode<T>\n  constructor() {\n    const qlList = new QuadList<T>()\n    this.nil = new DoubleLinkNode<T>(qlList)\n  }\n  firstLevel() {\n    if (this.nil.next === this.nil) {\n      this.insert()\n    }\n    return this.nil.next\n  }\n  insert() {\n    const ql = new QuadList<T>()\n    const node = new DoubleLinkNode(ql)\n    this.nil.next.prev = node\n    node.next = this.nil.next\n    this.nil.next = node\n    node.prev = this.nil\n    if (node.next !== this.nil) {\n      // link the above node and below node\n      node.val.nil.below = node.next.val.nil\n      node.next.val.nil.above = node.val.nil\n    }\n    return node\n  }\n  remove(node: DoubleLinkNode<T>) {\n    node.prev = node.next\n  }\n}\nclass QuadListNode<T> {\n  prev: QuadListNode<T>\n  next: QuadListNode<T>\n  above: QuadListNode<T> | null\n  below: QuadListNode<T> | null\n  val: T | undefined\n  constructor(val?: T) {\n    this.prev = this\n    this.next = this\n    this.above = null\n    this.below = null\n    this.val = val\n  }\n}\nclass QuadList<T> {\n  nil: QuadListNode<T>\n  constructor() {\n    this.nil = new QuadListNode()\n  }\n  static insertAboveAfter<T>(\n    newNode: QuadListNode<T>,\n    belowNode: QuadListNode<T> | null,\n    leftNode: QuadListNode<T>\n  ) {\n    newNode.next = leftNode.next\n    leftNode.next.prev = newNode\n    leftNode.next = newNode\n    if (belowNode) {\n      belowNode.above = newNode\n    }\n    newNode.prev = leftNode\n    newNode.below = belowNode\n  }\n  static remove<T>(node: QuadListNode<T>) {\n    node.prev.next = node.next\n    node.next.prev = node.prev\n  }\n}\ntype GetCompareKey = (a: any) => number\ninterface Position<T> {\n  dlNode: DoubleLinkNode<T>\n  qlNode: QuadListNode<T>\n}\n\n/**\n * a probabilistic data structure.\n * @category SkipList\n * @description\n * `search`, `insert`, `remove` achieve O(Logn) expected performance.\n * @example\n * ```js\n * const sl = new SkipList()\n * sl.insert(3)\n * sl.insert(1)\n * sl.insert(5)\n * sl.search(1) // => 1\n * ```\n */\nexport class SkipList<T> {\n  dl: DoubleLink<T>\n  mapValueKey: GetCompareKey\n  constructor(fn: GetCompareKey = x => x) {\n    this.dl = new DoubleLink()\n    this.mapValueKey = fn\n  }\n  private _search(\n    key: number,\n    dlNode: DoubleLinkNode<T> = this.dl.firstLevel(),\n    qlNode: QuadListNode<T> = dlNode.val.nil\n  ): Position<T> {\n    const tail = dlNode.val.nil\n    qlNode = qlNode.next\n    while (qlNode !== tail && this.mapValueKey(qlNode.val) <= key) {\n      qlNode = qlNode.next\n    }\n    qlNode = qlNode.prev\n\n    if (!qlNode.below) {\n      return {\n        dlNode,\n        qlNode,\n      }\n    }\n    qlNode = qlNode.below\n    return this._search(key, dlNode.next, qlNode)\n  }\n  search(key: number) {\n    const { qlNode } = this._search(key)\n    if (this.mapValueKey(qlNode.val) === key) {\n      return qlNode.val\n    }\n    return null\n  }\n  insert(value: T) {\n    let { qlNode, dlNode } = this._search(this.mapValueKey(value))\n    const newqlNode = new QuadListNode(value)\n    QuadList.insertAboveAfter(newqlNode, null, qlNode)\n    let belowNode = newqlNode\n    while (Math.random() < 0.5) {\n      const newqlNode = new QuadListNode(value)\n      while (qlNode !== dlNode.val.nil && !qlNode.above) {\n        qlNode = qlNode.prev\n      }\n      if (qlNode === dlNode.val.nil && dlNode.prev === this.dl.nil) {\n        dlNode = this.dl.insert()\n        qlNode = dlNode.val.nil\n      } else {\n        if (!qlNode.above) {\n          throw new Error('qlNode above must not be null')\n        }\n        qlNode = qlNode.above\n        dlNode = dlNode.prev\n      }\n      QuadList.insertAboveAfter(newqlNode, belowNode, qlNode)\n      belowNode = newqlNode\n    }\n  }\n  min() {\n    const tail = this.dl.nil.prev\n    return tail.val.nil.next.val\n  }\n  max() {\n    const tail = this.dl.nil.prev\n    return tail.val.nil.prev.val\n  }\n  remove(key: number) {\n    let { qlNode } = this._search(key)\n    if (this.mapValueKey(qlNode.val) === key) {\n      QuadList.remove(qlNode)\n      while (qlNode.above) {\n        qlNode = qlNode.above\n        QuadList.remove(qlNode)\n      }\n    }\n  }\n}\n","import { sortA, unique } from './array'\ninterface TreeNode {\n  l: number\n  r: number\n  v: any\n}\nabstract class SegmentTree<T> {\n  tree: TreeNode[]\n\n  constructor(\n    protected arr: T[],\n    protected getLeafValue: (v: any) => any,\n    protected getNotLeafValue: (vl: any, vr: any) => any\n  ) {\n    const n = arr.length\n    this.tree = Array(4 * n)\n    this._build(0, 0, n - 1)\n  }\n  protected _build(u: number, l: number, r: number) {\n    if (l === r) {\n      this.tree[u] = {\n        l,\n        r,\n        v: this.getLeafValue(this.arr[l]),\n      }\n      return\n    }\n    let m = Math.floor((l + r) / 2)\n    this._build(2 * u + 1, l, m)\n    this._build(2 * u + 2, m + 1, r)\n    this.tree[u] = {\n      l,\n      r,\n      v: this.getNotLeafValue(this.tree[2 * u + 1].v, this.tree[2 * u + 2].v),\n    }\n  }\n  protected _update(u: number, pos: number, v: T) {\n    const { l, r } = this.tree[u]\n    if (pos < l || pos > r) {\n      return\n    }\n    if (l === r) {\n      if (l === pos) {\n        this.tree[u].v = this.getLeafValue(v)\n      }\n      return\n    }\n    let m = Math.floor((l + r) / 2)\n    if (pos > m) {\n      this._update(2 * u + 2, pos, v)\n    } else {\n      this._update(2 * u + 1, pos, v)\n    }\n    this.tree[u].v = this.getNotLeafValue(\n      this.tree[2 * u + 1].v,\n      this.tree[2 * u + 2].v\n    )\n  }\n  abstract query(start: number, end: number): any\n  // abstract update(pos: number, value: T): void\n}\n\n/**\n * Max segment tree.\n * Query the maximum value of given range and update the value in O(Logn) time.\n *\n * @category segment tree\n * @example\n * ```js\n * const maxArr = new MaxArr([2,3,1,7,9])\n * const [l,r]=[0,2]\n * // find the maximum value from [l,r]\n * maxArr.query(l,r) //=> 3\n * maxArr.query(0,3) //=> 7\n * maxArr.update(1,9)\n * maxArr.query(0,3) //=> 9\n * ```\n * Provide the specified key\n * ```js\n * const maxArr = new MaxArr([{ name: 'li', age: 21 }, { name: 'wang', age: 24 }, { name: 'xx', age: 23 }],node=>node.age)\n * maxArr.query(0,2) //=> { name: 'wang', age: 24 }\n * maxArr.update(0, { name: 'xiao', age: 25 })\n * maxArr.query(0,2) //=> { name: 'xiao', age: 25 }\n * ```\n */\nexport class MaxArr<T> extends SegmentTree<T> {\n  mapValueKey: (node: T) => number\n  constructor(arr: T[], mapValueKey = (x: any) => x) {\n    super(\n      arr,\n      x => x,\n      (x, y) => {\n        return mapValueKey(x) - mapValueKey(y) >= 0 ? x : y\n      }\n    )\n    this.mapValueKey = mapValueKey\n  }\n  private _query(u: number, l: number, r: number): T | undefined {\n    const { l: _l, r: _r, v } = this.tree[u]\n    if (l <= _l && r >= _r) {\n      return v\n    }\n    if (r < _l || l > _r) {\n      return\n    }\n    let v1 = this._query(2 * u + 1, l, r)\n    let v2 = this._query(2 * u + 2, l, r)\n    if (v1 === undefined) {\n      return v2\n    } else if (v2 === undefined) {\n      return v1\n    }\n    return this.getNotLeafValue(v1, v2)\n  }\n  query(start = 0, end = this.arr.length - 1) {\n    return this._query(0, start, end)\n  }\n  update(pos: number, value: T) {\n    this.arr[pos] = value\n    this._update(0, pos, value)\n  }\n}\n\n/**\n * Sum segment tree.\n * Query the sum of given range and update the value in O(Logn) time.\n * @category segment tree\n * @example\n * ```js\n * const sumArr = new SumArr([2,3,1,7,9])\n * sumArr.query(0,2)\n * ```\n */\nexport class SumArr extends SegmentTree<number> {\n  constructor(arr: number[]) {\n    super(\n      arr,\n      x => x,\n      (x, y) => x + y\n    )\n  }\n  private _query(u: number, l: number, r: number): number {\n    const { l: _l, r: _r, v } = this.tree[u]\n    if (l <= _l && r >= _r) {\n      return v\n    }\n    if (r < _l || l > _r) {\n      return 0\n    }\n    let v1 = this._query(2 * u + 1, l, r)\n    let v2 = this._query(2 * u + 2, l, r)\n    return this.getNotLeafValue(v1, v2)\n  }\n  query(start = 0, end = this.arr.length - 1): number {\n    return this._query(0, start, end)\n  }\n  update(pos: number, value: number) {\n    this.arr[pos] = value\n    this._update(0, pos, value)\n  }\n}\n\n/**\n * Given an array contains all the values,\n * insert the value one by one,and\n *  query the number of value in [lower,upper].\n * @category segment tree\n * @example\n * ```js\n * const arr = [1, 2, 3, 5, 7]\n * const vArr = new ValueArr(arr)\n * vArr.insert(1)\n * vArr.insert(3)\n * vArr.insert(5)\n * assert.strictEqual(vArr.query(1, 3), 2)\n * assert.strictEqual(vArr.query(1, 5), 3)\n * vArr.insert(1)\n * assert.strictEqual(vArr.query(1, 5), 4)\n * ```\n */\nexport class ValueArr extends SegmentTree<number> {\n  constructor(arr: number[]) {\n    super(\n      sortA(unique(arr)),\n      () => 0,\n      (x, y) => x + y\n    )\n  }\n  private _query(u: number, low: number, upper: number): number {\n    const { l, r, v } = this.tree[u]\n    const lv = this.arr[l]\n    const rv = this.arr[r]\n    if (low <= lv && upper >= rv) {\n      return v\n    } else if (low > rv || upper < lv) {\n      return 0\n    }\n    return (\n      this._query(2 * u + 1, low, upper) + this._query(2 * u + 2, low, upper)\n    )\n  }\n  query(low: number, upper: number): number {\n    return this._query(0, low, upper)\n  }\n  private _insert(u: number, v: number) {\n    const node = this.tree[u]\n    const { l, r } = node\n    const lv = this.arr[l]\n    const rv = this.arr[r]\n    if (lv <= v && rv >= v) {\n      node.v++\n      if (l < r) {\n        this._insert(2 * u + 1, v)\n        this._insert(2 * u + 2, v)\n      }\n    }\n  }\n  insert(v: number) {\n    this._insert(0, v)\n  }\n}\n","/**\n * @category Union-find data structure\n * @example\n * ```js\n * const uf=new UnionFind(4);\n * uf.union(0, 1);\n * uf.union(1, 2);\n * uf.isSameSet(0, 2); //=> true\n * ```\n */\nexport class UnionFind {\n  size: number\n  fatherMap: number[]\n  sizeMap: number[]\n  /**\n   * @param n the  number of node\n   */\n  constructor(n: number) {\n    this.fatherMap = Array(n).fill(-1)\n    this.sizeMap = Array(n).fill(1)\n    this.size = n\n  }\n  /**\n   * find set representatives use `path compression`\n   * @param node\n   */\n  find(node: number): number {\n    if (this.fatherMap[node] === -1) {\n      return node\n    }\n    this.fatherMap[node] = this.find(this.fatherMap[node])\n    return this.fatherMap[node]\n  }\n  isSameSet(node1: number, node2: number): boolean {\n    const root1 = this.find(node1)\n    const root2 = this.find(node2)\n    return root1 === root2\n  }\n  /**\n   * merge two sets\n   * @param node1\n   * @param node2\n   */\n  union(node1: number, node2: number): void {\n    const root1 = this.find(node1)\n    const root2 = this.find(node2)\n    if (root1 === root2) {\n      return\n    }\n    if (this.sizeMap[root1] > this.sizeMap[root2]) {\n      this.fatherMap[root2] = root1\n      this.sizeMap[root2] = this.sizeMap[root2] + this.sizeMap[root1]\n    } else {\n      this.fatherMap[root1] = root2\n      this.sizeMap[root1] = this.sizeMap[root2] + this.sizeMap[root1]\n    }\n  }\n}\n","import { last } from './array'\nimport { TreeNode } from './treeNode'\n\n/**\n * The traversalFn will be executed in post-order\n * @param root\n * @param traversalFn\n * @category tree traversal\n * @mermaid\n *  flowchart TD\n *    B-->A\n *    B-->D\n *    D-->C\n * \t  D-->E\n * @example\n * ```js\n * postorder(root,(node,fatherNode)=>{console.log(node)})\n * // => A C E D B\n * ```\n */\nexport function postorder<T>(\n  root: TreeNode<T>,\n  fn1: (node: TreeNode<T>) => any\n) {\n  if (!root) {\n    return\n  }\n  let map = new Map()\n  let queue = [root]\n  while (queue.length) {\n    let top = last(queue)\n    if (!map.get(top)) {\n      map.set(top, true)\n      if (top.right) {\n        queue.push(top.right)\n      }\n      if (top.left) {\n        queue.push(top.left)\n      }\n    } else {\n      queue.pop()\n      fn1(top)\n    }\n  }\n}\n\n/**\n * The traversalFn will be executed in in-order\n * @param root\n * @param traversalFn\n * @category tree traversal\n * @mermaid\n *  flowchart TD\n *    B-->A\n *    B-->D\n *    D-->C\n * \t  D-->E\n * @example\n * ```js\n * inorder(root,(node,fatherNode)=>{console.log(node)})\n * // => A B C D E\n * ```\n */\nexport function inorder<T>(root: TreeNode<T>, fn1: (node: TreeNode<T>) => any) {\n  if (!root) {\n    return\n  }\n  let map = new Map()\n  let queue = [root]\n  while (queue.length) {\n    let top = last(queue)\n    if (!map.get(top)) {\n      map.set(top, true)\n      if (top.left) {\n        queue.push(top.left)\n      }\n    } else {\n      queue.pop()\n      fn1(top)\n      if (top.right) {\n        queue.push(top.right)\n      }\n    }\n  }\n}\n\n/**\n * The traversalFn will be executed in pre-order\n * @param root\n * @param traversalFn\n * @category tree traversal\n * @mermaid\n *  flowchart TD\n *    B-->A\n *    B-->D\n *    D-->C\n * \t  D-->E\n * @example\n * ```js\n * prevorder(root,(node,fatherNode)=>{console.log(node)})\n * // => B A D C E\n * ```\n */\nexport function prevorder<T>(\n  root: TreeNode<T>,\n  traversalFn: (node: TreeNode<T>, fatherNode: TreeNode<T> | null) => any\n) {\n  if (!root) {\n    return\n  }\n  let queue = [root]\n  let fatherMap = new Map()\n  fatherMap.set(root, null)\n  while (queue.length) {\n    let top = queue.pop() as TreeNode<T>\n    traversalFn(top, fatherMap.get(top))\n\n    if (top.right) {\n      fatherMap.set(top.right, top)\n      queue.push(top.right)\n    }\n    if (top.left) {\n      fatherMap.set(top.left, top)\n      queue.push(top.left)\n    }\n  }\n}\n"],"names":["TreeNode","constructor","val","left","right","serialize","root","JSON","stringify","arr","queue","length","node","shift","push","i","deserialize","originData","data","parse","leftVal","undefined","rightVal","outArr","join","ListNode","next","head","header","out","prev","cur","compare","v1","v2","Error","localeCompare","sortA","fn","x","fn2","sort","y","sortD","getCompareKey","getCompareKey2","key1","r","key3","last","unique","Set","dfs","set","adjArr","add","adjNodes","has","dfs2","index","isConnected","j","isNil","value","bfs","map","dist","m","shortDis","Infinity","nextNode","get","adjNode","medium","lastValue","Math","floor","ceil","random","min","max","c","n","bm","BigInt","bn","s","s2","RBSTNode","PQ","keys","mapValueKey","this","sink","insert","key","swim","exch","less","father","len","peek","poll","isEmpty","size","DoubleLinkNode","DoubleLink","qlList","QuadList","nil","firstLevel","ql","below","above","remove","QuadListNode","newNode","belowNode","leftNode","SegmentTree","getLeafValue","getNotLeafValue","tree","Array","_build","u","l","v","_update","pos","_query","_l","_r","query","start","end","update","delMax","delMin","insertAsRoot","item","split","leftTree","rightTree","total","_insert","search","curKey","p","newTree","findKMax","k","prevNum","curRank","dl","_search","dlNode","qlNode","tail","newqlNode","insertAboveAfter","fatherMap","fill","sizeMap","find","isSameSet","node1","node2","union","root1","root2","low","upper","lv","rv","num","d","Number","result","t","gcd","a","b","adjMatrix","Map","initArray","dimension","isInteger","isArray","from","slice","fn1","top","pop","arr1","arr2","e","arg","intervals","interval","remainder","reverse","traversalFn","x0","y0","reduce","indexArr"],"mappings":"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"}